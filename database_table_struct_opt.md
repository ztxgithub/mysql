# 数据库表结构优化

## 基础知识

```shell
    1.一个sql语句中所关联的表越多，其读数据库性能就越差
    2.完全符合范式化的设计有时并不能得到良好的SQL查询性能
```


## 数据库结构优化的目的

```shell
    1.尽量减少数据冗余
    2.尽量避免数据维护中出现更新，插入和删除异常。
        插入异常：如果表中某个实体随着另一个实体而存在.例如在course表中有联合主键(student_no(学号)，course_name(课程名))，
                 如果在插入记录中只插入course_name不插入相关的学号，则会产生插入失败
                 
        更新异常: 如果更改表中的某个实体的单独属性时，需要对多行进行更新。例如course表中要更新数学科目对应的学分，那么要对记录中所有
                 数学所对应的学分都要改为相应的值。
        删除异常:如果删除表中某一个实体则会导致其他实体的消失，如果要删除某个student_no(学号)，则会导致多条记录被删除。
        
    3.节约数据存储空间
    4.提高查询效率
```

## 数据库结构设计的步骤

```shell
    1.需求分析：全面了解产品设计的存储需求，需要考虑到
                存储需求：数据库需要存储什么数据
                数据处理需求：我们需要如何对数据库进行读取或者修改已完成业务的功能，以及对数据处理的响应时间的要求
                数据的安全性和完整性
                
    2.逻辑设计：设计数据的逻辑存储结构，在这个阶段我们不用关心使用什么数据库，什么存储引擎。我们需要搞清楚数据实体之间的
               逻辑关系，避免数据冗余和数据维护异常，这个阶段会影响以后的数据库处理，可以参考数据库的设计范式(可以解决
               数据冗余和数据维护异常)
               
    3.物理设计：根据所使用的数据库特点进行表结构设计，需要采用什么存储引擎，表中的列采用什么数据类型
    4.维护优化：根据实际情况对索引，存储结构等进行优化
```

## 数据库的逻辑设计

### 数据库设计范式

```shell
    数据库设计范式:在进行数据库设计时要遵从一些规范，设计出没有数据冗余和数据维护异常的数据库结构。
    
    注意:
         数据库设计范式不能达到性能最优，在真实设计数据库时，要考虑实际的业务使用情况(所有有的时候做一些反范式设计)
    
    数据库三范式:
        (1) 第一范式:
                    A:数据库表中的所有字段都只具有单一属性(不能进行分解)
                    B:单一属性的列是由基本的数据类型所构成的(比如整型，浮点型，字符型)
                    C:设计出来的表都是简单的二维表。
                    
        (2) 第二范式: 在第一范式的基础之上定义的，符合第二范式的表一定符合第一范式，要求一个表中只具有一个业务主键，
                     也就是说符合第二范式的表中不能存在非主键列对 只对部分主键的依赖关系.如果一个表中是复合主键则
                     它可能不具备第二范式，一般只要一张表中只有一个主键就基本符合第二范式。
                     
                     例如表course(student_id,student_name,birth_date,course_name,score,
                     course_point(学分))， 该表中 primary key(student_id,course_name) 联合主键。在这个表中
                     非主键列(学分) 只对部分主键(course_name)的依赖关系,跟部分主键(student_id)没有关系，所以这个
                     表是不符合第二范式，
                     改造方法:
                        对该表进行拆分使其符合第二范式，将该表拆分为3张表(学生表,课程表,学生课程映射表)
                        1.学生表student_table(student_id,student_name,birth_date) primary key(student_id) 只有一个主键
                        2.课程表course_table(course_name,course_point) primary key(course_name) 只有一个主键
                        3.学生课程映射表student_course_map(student_id,course_name,score)
                                    primary key(student_id,course_name)
                                    
        (3) 第三范式: 指每一个非主属性 不 部分依赖于业务主键，也不 传递依赖与业务主键，也就是在第二范式的基础上消除了
                     非主属性对主键的传递依赖(非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况)
                     
                     例如，订单表Order(OrderID，OrderDate，CustomerID，CustomerName，CustomerAddr，CustomerCity) 
                               primary key(OrderID) 只有一个主键,
                               
                          而CustomerName，CustomerAddr，CustomerCity 直接依赖的是 CustomerID（非主键列），
                          而不是直接依赖于主键，它是通过传递才依赖于主键，所以不符合 3NF。 
                          
                     改造方法:
                        对该表进行拆分使其符合第三范式，将该表拆分为3张表(学生基本信息表,学院信息表)
                        1.订单表Order(OrderID,OrderDate,CustomerID)
                          primary key(OrderID) 只有一个主键
                     
                        2.客户表Customer(CustomerID，CustomerName，CustomerAddr，CustomerCity)
                        
    范式化的优点:
        (1) 尽量得减少数据冗余
        (2) 范式化的更新操作要比反范式化更快(跟冗余数据有关)，即在数据库中对于写频繁操作SQL效率要高
        (3) 范式化的表要比反范式化的表小
        
    范式化的缺点:
        (1) 对于查询需要对多个表进行关联, 同时对读SQL语句效率要差
        (2) 更难进行索引优化(范式化设计使得经常使用的列存放在不同表中，如果这些列在同一个表中可以属于同一个索引)
```

### 需求分析及逻辑设计

```shell
    1.需求说明: 按照下面的需求设计一个电子商务网站的数据库结构：
                    (1) 本网站只销售图书类的商品
                    (2) 需要具有一下功能:
                            A:用户登陆  B:用户管理  C:商品展示 D:商品管理 E:供应商管理 F:在线销售
                            
    2.需求分析
            (1) 用户登陆及用户管理功能
                    A：用户必须注册并登陆系统才能进行网上交易
                            这边用户名在用户信息中作为唯一的主键
                    B: 同一用户在同一时间只能在一个地方登陆
                            在用户登陆过程中要考虑在数据库中 用户的登陆状态 ，
                    C：用户信息表(用户名，密码，手机号，姓名，注册日期，在线状态，出生日期) primary key(用户名)
                       该表只有一个业务主键(用户名)，符合第二范式.
                       该表的属性中不存在与业务属性有传递依赖的关系，符合第三范式
                                       
```

### 数据库反范式设计

```shell
        反范式化是针对范式化而言，其为了性能和读取效率的考虑而适当的对数据库进行数据冗余，已达到空间换时间。
        
    反范式化的优点:
        (1) 减少表的关联(由于经常查询的列在同一张表中，全表扫描的性能要比表关联要好一些，如果使用了innodb,进行全表扫描是顺序IO，
                        而表关联则是对应与随机IO)
        (2) 可以更好得进行索引优化
        
    反范式化的缺点:
        (1) 存在大量的数据冗余及数据维护异常
        (2) 对数据的修改则需要更多的成本
        
                                       
```

## 数据库的物理设计

```shell
    物理设计概念:根据 所选择的关系型数据库的特点 对逻辑模型进行 存储结构设计
    
    物理设计涉及内容:
        (1) 定义数据库，表及字段的命名规范
        (2) 选择合适的存储引擎
        (3) 为表中的字段建立合适的数据类型
        (4) 建立数据库表结构
                                              
```

### 定义数据库，表及字段的命名规范

```shell
    这是考虑到多人联合开发,数据库，表及字段的 可读性(例如都使用小写字母),表意性原则(知道该表是用来做什么的)，
    长命名原则(单词尽量完整)
                                              
```

### 为表中的字段建立合适的数据类型

```shell
    当一个列可以选择多种数据类型时，应该优先选择数值型(int),其次是日期或则二进制类型，最后考虑字符类型,对于相同级别的数据类型，
    应该选择 占用空间小 的数据类型，
    原因：
        (1) 在对数据进行查找，比较，关联排序时，字符类型要与排序规则相关的，而数值型比较是按照二进制大小，采用字符类型处理起来较慢
        (2) 在数据库中，数据处理按页为单位的，每个页存储数据量是一定的(innodb 16KB)， 字段占用空间小则代表一个页中包含更多的数据，
            针对相同的业务所加载的数据库的页较小，这样减少了磁盘的IO，提高性能。
            
    整数类型:
                                            取值范围
            列类型    存储空间    SIGNED                   UNSIGNED
            tinyint   1字节     -128~127                  0~255
            smallint  2字节     -32768~32767              0~65535
            mediumint 3字节     -8388608~8388607          0~16777215
            int       4字节     -2147483648~2147483647    0~4294967295
            bigint    8字节     
            
            
    实数类型：
            列类型     存储空间                                    是否精确类型
            float       4字节                                         否
            double      8字节                                         否
            decimal   每4个字节存9个数字，小数点占一个字节                是
            
            备注: 2个float相加不一定等于理论上的值。
                 如果我们要存储财务相关的数据，则要用decimal数据类型
         
    
    字符串类型:
        varchar：
            (1) varchar类型的存储特点
                    1. varchar用于存储变长字符串(字符串的长度不固定)，只占用必要的存储空间,例如有个宽度为50的varchar列
                        如果只存储了10个字符，那么这个时候存储空间只占用10个字符的存储宽度，这里1个字符不一定等于1个字节，
                        以utf8为例，1个字符要占用3个字节，在字符数据类型定义中，宽度是以 字符 为单位的
                    2. 列的最大长度(以字符为单位)小于255则只占用一个额外字节用于记录字符串长度
                    3. 列的最大长度大于255则要占用2个额外字节用于记录字符串长度，这就决定了varchar的最大宽度是65535字符
            (2) varchar列宽度大小的选择
                    1. 尽量使用符合需求的宽度(需要熟悉对应的业务，不能在线上进行修改，这样会导致数据库锁表使得性能极大得下降)
                    2. varchar(5)与varchar(200) 存储 “test”字符串，其性能不同(虽然都使用相同的一个额外字节)，在mysql
                        最有效的优化查询，在内存中读数据是用固定的宽度，如果宽度定的太长会增加内存的消耗
                        
            (3) varchar的适用场景
                    1.字符串列的最大长度比平均长度大很多，相比与char固定长度(该固定长度的值以最大字符串长度)，会使用更少的存储空间
                    2.字符串列很少被更新(varchar字段的更新导致实际存储的长度会发生变化，导致数据库分页等问题)
                    3.使用多字节字符集 存储字符串，像utf8
                    
        char：
            (1) char类型的存储特点
                    1. char类型是定长的
                    2. 字符串存储在char类型的列会删除末尾的空格,同样的字符串存储在varchar类型中其末尾的空格是不会被删除的
                    3. char类型的最大宽度只有255，如果超过255宽度只能用
                    
            (2) char类型适用的场景
                    1.char类型适合存储长度都相近的值(例如MD5值，身份证等)
                    2.char类型适合存储短字符串
                    3.char类型适合存储经常更新的字符串
                    
        longtext:
            可以不指明长度，这样可以添加任何长度，
                    
    日期类型：
        datetime类型:
            以 YYYY-MM-DD HH:MM:SS[.fraction] 格式存储日期时间，其中.fraction是代表微妙
            1.精确到秒 datetime = YYYY-MM-DD HH:MM:SS
            2.精确到微妙 datetime(6) = YYYY-MM-DD HH:MM:SS.fraction
            
            datetime类型与时区无关(不管mysql中系统变量time_zone的值为多少)，占用8个字节的存储空间
            
            时间范围 1000-01-01 00:00:00 到 9999-12-31 23:59:59
            
        timestamp类型
            时间戳(从格林尼治1970年1月1日到当前时间的秒数)
            
            我们在看的时候(显示) 是以YYYY-MM-DD HH:MM:SS[.fraction] 格式呈现的，它是占用4个字节(int型存储)
            时间范围 1970-01-01 到 2038-01-19
            
            timestamp类型显示依赖于所指定的时区(在不同的时区会显示不同的值)
            
            在行的数据修改时可以自动修改timestamp类型所对应列的值，如果数据库表中有2个以上timestamp日期类型，则默认只会更新第一个
            timestamp日期类型
            
            
        如何存储时间部分数据
            date类型
                例如表中的生日字段只需要保持日期(年月日)。
            
                date类型的优点：
                    1.占用字节数比使用字符串，datetime，int存储要少，使用date类型只需要3个字节
                    2.使用date类型还可以利用日期时间函数进行日期之间的计算
                
                date时间范围 1000-01-01 00:00:00 到 9999-12-31 23:59:59
                
                
           time类型
               time类型适用与存储 时分秒 的数据，格式 HH:MM:SS
               通过数据类型的宽度的定义指定微妙。
               
        注意事项:
            1.不要使用字符串类型来存储日期时间数据（原因是日期时间类型要比字符串占用的存储空间小，日期时间类型在进行查找过滤时可以利用
                                               日期来进行对比,日期时间类型有很多时间处理函数，方便对日期时间类型进行计算)
            2.使用int类型存储时间戳还不如使用timestamp类型
                                                   
```

## 总结

```shell
    1.如何为innodb选择主键
        (1) 主键应该尽可能的小
        (2) 主键应该是顺序增长的（表的逻辑顺序与innodb存储是相同的，逻辑上顺序插入则对应的物理上也会顺序插入，增加数据的插入效率）
        (3) innodb的主键和业务主键可以不同，如果业务主键不能满足以上1,2的条件，则将自增id作为innodb的主键
                                              
```