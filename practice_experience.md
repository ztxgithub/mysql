# 基础知识

```shell
    1. QPS:每秒钟的查询量
    2. DML（data manipulation language）：用来对数据库里的数据进行操作的语言，有SELECT、UPDATE、INSERT、DELETE
    3. DDL（data definition language）：
            用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。
            主要的命令有CREATE、ALTER、DROP以及创建索引等。
    4. DCL（Data Control Language）：
            是数据库控制功能。是用来设置或更改数据库用户或角色权限的语句
            包括（grant,deny,revoke等）语句。在默认状态下，只有sysadmin,dbcreator,db_owner或db_securityadmin等人员
            才有权力执行DCL
    5. 事务：是一组具有原子性的SQL语句，要么都执行完这些SQL语句，要么都不执行。
            有4个特性 
                (1) 原子性：事务被视为不可分割的最小工作单位，要么commit成功，要么回滚到原来的
                (2) 一致性：操作的对象(数据)在数据库中是存在的，不能消失。比如银行的例子，一个转账事务有若干个SQL语句构成，
                            第一个SQL语句从A中扣掉1000元，第二个SQL语句从B中加上1000元。这两个是一起执行的，一致性是1000元在
                            数据库中不能消失。
                (3) 隔离性：一个事务对数据库中数据的修改，在未提交完成前对其他事务是不可见的。
                           数据库命令(mysql> show variables like '%iso%'; 或者 > SELECT @@global.tx_isolation)
                                tx_isolation ： READ-COMMITTED
                                1.未提交读(read uncommited)
                                    会读到脏数据，在一个事务1中(开始begin;)进行select读表A的数据，在另外一个事务2中(begin;)向
                                    表A中插入数据data_new(事务2还没有commit),如果这时事务1再进行select读表A，那么会读到data_new
                                    
                                2.已提交读(read commited)
                                    在一个事务1中(开始begin;)进行select读表A的数据，在另外一个事务2中(begin;)向
                                    表A中插入数据data_new(事务2还没有commit),这时事务1再进行select读表A，不会读到data_new，
                                    只有当事务2进行commit后，事务1进行select读表A才会读到data_new.这个时候会有问题,是在事务中
                                    不能重复读，因为在一个事务中读到的数据随时可以会发生变化(另一个事务对同一张表进行操作)
                                    
                                3.可重复读(repeatable read)(mysql默认隔离级别)
                                     解决已提交读问题，在一个事务中不管读多少次，数据都不会发生变化(即使有另一个事务对同一张表进行操作)
                                     
                                4.可串行化（Serializable）
                                    完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞(一般不使用)
                                    
                                   
                (4) 持久性：一旦事务被提交，所做的修改会永久的保存到数据库中。
                                    
```

# 影响数据库的性能

```shell
    1. 大量的并发和超高的CPU使用率
            大量的并发会使得数据库的连接数被占满(max_connections),超高的CPU使用率可能会宕机.
            
    2.网络IO
        避免无法连接到数据库
            (1) 减少从服务器的数量
            (2) 进行分级缓存
            (3) 避免使用"select *" 查询
            
    3.大表
        大表：(1)单表的记录超过千万行.(2)表数据文件超过10GB
        
        问题：
           1.大表会导致查询效率低，如果某个表中包含千万条记录且某一列中只有4中情况条件,如果要查询筛选出1种情况,那么会导致区分度低，
             有大量的数据被读出，大量的磁盘IO从而导致减低了磁盘的效率.
           2.对DDL操作的影响
                (1) 大表使得建立索引需要很长的时间，mysql版本<5.5(建立索引会长时间的锁表)。mysql版本>=5.5(建立索引虽然不会长时间锁表
                    但会造成主从数据同步长时间延迟)
                (2) 修改表结构需要长时间的锁表。这样主数据库修改完后从数据库也要修改而且时同步的，只要当主数据库修改完表结构相应的
                    从数据库才能进行修改，会长时间的造成主从延时。这时候如果有对该表进行数据操作时，那么得等主从数据库表都修改完
                    表结构才能进行，这时操作会阻塞导致数据库的连接数剧增。
        
        解决方法：
            1.可以对大表进行历史数据归档
                    要考虑到归档时间点的选择，如何进行归档操作(可以会导致主从延时和其他业务数据查询的阻塞)
               
    4.大事务(运行时间长,操作的数据量大)
        
        问题：
            (1) 锁定大量的数据,造成大量的阻塞和锁超时
            (2) 回滚所需要的时间较长.
            (3) 会造成主从延时,只有当事务在主数据库中操作完成,将操作记录到binlog中，从数据库服务器根据binlog进行相同的事务操作.
            
        解决方法:
            (1) 避免一次处理太多的数据,可以进行分批次进行处理，一个事务可以只处理定量的数据，然后分成多个事务.
            (2) 在事务中移除不必要的select操作
            
    5.数据库参数的配置
    
    6.数据库表结构设计和SQL语句
    
    7.服务器硬件
        
        

```

# 数据库实战经验

```shell
    1. 最好不要在数据库主库(master)上进行数据库备份远程同步计划任务，大型活动前取消这类计划任务.因为这些同步计划任务会导致服务器的性能
        下降,使得其他正常的服务有堵塞现象.
        
    2.大多数数据库性能的问题可以通过对sql查询的优化来解决(慢查询问题)
```

