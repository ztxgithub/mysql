# Mysql复制

## Mysql复制概念

```shell
    Mysql复制功能提供了分担 读负载，通过复制功能对数据库进行水平扩展，为数据库服务器增加一个或多个备库，这些备库可以分担读负载。
    Mysql复制功能为高可用，灾难恢复，备份提供更多的选择。
    Mysql的复制是基于主库上的二进制日志，Mysql的复制是异步的，可以存在主从数据库不一致，
    
    Mysql复制所解决的问题:
        (1) 实现在不同服务器上的数据分布(Mysql复制是利用二进制日志增量进行，不需要太多的带宽，但是使用基于行的复制在进行大批量的
                                     更改时会对带宽带来一定的压力，应该分批进行)
        (2) 实现数据读取的负载均衡(需要其他组件配合完成，例如利用DNS轮询的方式把程序的读 连接到不同的备份数据库中，
                                也可以使用LVS，haproxy等方式)
        (3) 增加数据的安全性(复制并不能代替备份，复制只是将主库的数据拷贝到从库中，由于主从同步的延时小，如果主库中有大量错误数据，
                           则从库也很快被同步扩散，不能通过从库恢复到主库，而是得用备份的方式)
        (4) 实现数据库高可用和故障切换。
        (5) 实现数据库的在线升级
        

```

## Mysql二进制日志

```shell
    Mysql日志类型:
        (1) MySQL服务层日志
                例如二进制日志，慢查日志，通用日志，这些日志与存储引擎无关，是由MySQL服务器层来记录的，
        (2) MySQL存储引擎层日志：例如innodb重做日志和innodb回滚日志
        
    二进制日志(binlog)
        记录了所有对MySQL数据库的修改事件，包括增删改查事件和对表结构的修改事件,在binlog日志中记录的事件都是已经成功执行的，对于已经
        回滚的事件不会记录在binlog日志中
        
    二进制日志的格式
        (1) 基于段的格式 
                特点:
                    数据库系统变量binlog_format = STATEMENT,  其记录的是执行的SQL语句,如果数据库采用这种方式，在终端执行
                    mysqlbinlog命令时不需要指定任何参数，就可以清楚得从二进制日志中看出执行了那些二进制语句，
                    不管数据库系统变量binlog_format 是何值，在进行 DDL(表结构操作)时都是用基于段的格式记录在biglog中.
                    
                优点:
                    1.日记记录量相对较小(记录的只是每一个事件的SQL语句)，节约磁盘及网络I/O，只对一条记录修改或则插入，row格式
                      所产生的日志量小于 段产生的日志量
                
                缺点:
                    1.必须记录上下文信息，保证语句在从服务器上执行结果和在主服务器上相同。但是特定函数如UUID(),user(),这样非确定性
                      函数还是无法复制，这可能造成MySQL复制的主备服务器数据不一致。
                        
                        
        (2) 基于行的格式 
                特点:
                    数据库系统变量binlog_format = ROW（MySQL的默认使用格式）,Row可以避免MySQL复制中出现的主从不一致问题，推荐使用
                    这种二进制日志格式，这种日志记录的是增删改查操作所修改数据行的信息，每修改一行就会有一条记录，同一条SQL语句修改了
                    10000条数据的情况下，基于段的二进制日志格式只会记录这个SQL语句，而基于行的二进制日志格式会有10000条记录分别记录
                    每一个行的数据修改
                    
                优点:
                    1.使MySQL主从复制更加安全，由于ROW格式记录每一个记录的修改，所以传到从服务器上只需要应用其更改就行了，而不是按照
                      SQL语句进行应用，在主服务器该了什么，同样的也会在从服务器更改相同的地方，确保主从数据一致。
                    2.ROW格式是记录了每一行的修改，这要比基于段格式的复制要高效，减低主从复制的时间
                    3.误操作而修改了数据库的数据，同时又没有备份可以恢复时，我们就可以通过分析ROW格式二进制日志，
                      对日志中记录的数据修改操作做反向处理的方式来达到恢复数据的目的
                
                缺点:
                    1.记录日志量大，消耗更多的磁盘IO和网络IO
                    
        (3) 混合日志格式
                特定:
                    数据库系统变量binlog_format = MIXED,它是基于段的日志格式和行的日志格式的折衷的选择，
                    1.根据SQL语句由系统决定在基于段的日志格式和基于在行的日志格式中进行选择
                    2.数据量的大小由所执行的SQL语句决定的
    
        
    命令 mysqlbinlog 
       (1) 如果binlog的格式是 段格式(statement)  > mysqlbinlog 二进制日志
       
    如何选择二进制日志格式
        建议： 尽量使用 binlog_format = ROW 或则 binlog_format = MIXED，
              在使用 binlog_format = ROW时，尽量使用 binlog_row_image=MINIMAL
    

```

## MySQL 二进制日志相关的参数

```shell
    1.对于 ROW格式的二进制日志 
            binlog_row_image 值
                (1) FULL(默认的): 一行数据修改时会记录这行所有列的内容，无论这些列是否都被修改过
                (2) MINIMAL: 一行数据修改时只会记录 被修改的列，如果数据库表中有20，SQL操作只update其中这一列，则只会记录这一列的内容
                (3) NOBLOB:跟FULL一样，只不过当text和BLOB没有修改时，是不会记录的
    

```

## 基于二进制日志格式的复制

```shell

    MySQL复制类型
        1.基于SQL语句的复制(SBR)
            主数据库服务器的二进制日志格式使用的是statement格式
        
        2.基于行的复制(RBR)
            主数据库服务器的二进制日志格式使用的是行格式
            
        3.混合格式
            根据实际内容在以上2中模式切换
            
           
    MySQL二进制日志格式对复制的影响
        1.基于SQL语句的复制(SBR)：又称为逻辑复制，在这种模式下，主库的SQL语句对应的在从库上重新执行一次
                优点：
                     (1) 生产日志量少，节约网络传输I/O
                     (2) 并不强制要求主从数据库的表定义完全相同。
                     (3) 相比于基于行的复制方式更加灵活。由于日志记录中就是主库的SQL语句，很容易定位问题的发生
                     
                缺点:
                    (1) 对于非确定性事件，无法保证主从复制数据的一致性。例如特定的函数UUID()在主从执行的结果是不一样的。
                    (2) 对应存储过程，触发器，自定义函数进行修改也可能导致主从数据不一致
                    (3) 相比于行的复制方式，在从数据库上执行时需要更多行锁。 该SQL语句在主库时要锁定多少行数据，同样的对应的从
                        数据库上也要锁定相同的数据。如果使用行复制方式，则只要在从数据库上锁定更新行的数据就行。
                        
        2.基于行的复制(RBR):
                优点：
                    (1) 可以应用于任何SQL语句的复制包括非确定性函数，存储过程等
                    (2) 减少从数据库锁的使用，减少主从复制的时间，增强性能。
                    
                缺点:
                    (1) 要求主从数据库表结构相同，否则可能会中断复制.其主从数据库表列的顺序也要是一样的。
                    (2) 无法在主从上单独执行触发器，基于行的复制是直接在从服务器上 应用主数据库对行的修改，而不是在从服务器上
                        重新执行SQL，所以有时我们只想在从服务器上执行一些触发器以记录数据的变更，比如用于数据抽取，我们就需要
                        在单独从服务器上执行触发器，对某些表的变更进行记录以方便我们做增量抽取，在这种情况下，基于SQL语句的复制
                        是完全可以运行的，因为它只是在从服务器上执行SQL语句，同样会触发我们在从服务器上的触发器。但是基于行的复制
                        是无法工作，在行的复制中并没有执行SQL语句，而是直接应用了对行数据的修改，这样是不会触发在从服务器上的触发器。
                        
        使用建议： 推荐使用基于行的复制，对主从数据的一致性更加有保证
            
```

## MySQL复制的工作方式

```shell

  MySQL复制过程:
    1.主数据库将变更写入二进制日志中(MySQL必须开启记录二进制日志功能)
    2.从数据库读取主数据库的二进制日志的变更信息 写到自身 relay log(中继日志) 中。 要完成这一个过程，需要在从服务器上建立I/O线程，
      这个I/O线程会跟主服务器建立连接，这时在主服务器上建立转储线程(binlog down),从库上的I/O线程通过这个二进制转储线程读取主库上
      的二进制日志的事件，I/O线程不会轮询的读取事件，如果I/O线程已经读完所有变更的事件，就进行sleep等待直到主库发送信号，I/O线程才被唤醒
      继续读主库上的新的二进制日志事件，中继日志的格式和二进制日志格式相同的，我们可以使用mysqlbinlog工具读取中继日志的内容，如何指定从
      什么位置开始读取，复制可以分为 基于日志点的复制 和 基于GTID的复制
      
    3.从服务器重放 relay log中的日志，这个过程由从服务器的SQL线程执行。根据日志格式不同，分为2中执行方式，有
      基于SQL段的日志(从库上重新执行记录的SQL) 和 基于行的日志(从库上直接应用对数据库行的修改)
      
      
  基于日志点的复制：
  
       基本原理:
            在从库服务器中通过读取哪个二进制日志(mysql-binlog.000002)和偏移量进行增量同步，如果指定错误会造成遗漏或则重复，导致
            主从不一致
       1.基于日志点的复制的配置步骤:
            (1) 在主DB服务器上建立复制账号
                    I.创建用户
                        mysql> create user ‘用户名’ @ ‘允许使用的ip网段' identified by '密码'
                        例如
                         mysql> create user ‘jame’ @ ‘192.168.3.%' identified by '123456';
                    II.授权
                        mysql> grant replication slave on *.* to 用户名’ @ ‘允许使用的ip网段'
                        其中 replication slave 是一种权限类型
                        例如
                           mysql> grant replication slave on *.* to 'jame’ @ ‘192.168.3.%';
            (2) 配置主数据库服务器(在/etc/my.cnf)
                    I.  log-bin=mysql-bin  (用来启动mysql二进制日志，指定mysql二进制日志名字规范 /home/mysql/log/mysql-bin)
                    II. server_id = 100 (在所有数据库中要确保唯一)
                    可选：
                        max_binlog_size = 1000M
                        binlog_format = row
                        expire_logs_days = 7
                        sync_binlog = 1
            (3) 配置从数据库服务器
                    I. log-bin = mysql-bin(在从数据库配置binlog方便以后进行主从迁移，故障转移，进行连路复制)
                    II. server_id = 101
                    III. relay_log = mysql_relay_bin (一定要进行固定，默认是按主机名字进行命名 /home/mysql/log/mysql-relay-bin)
                    IV. log_slave_update = on [可选] (如果以后要将该从服务器当做主服务器使用则一定要设置为on)
                    V. read_only = on [可选] (安全配置参数)
                    
            (4) 初始化从数据库的数据
                    在主从服务器配置完成之后，可以准备复制链路，这这之前还要先把主数据库的现有数据拷贝到从服务器中，如果我们的主库中
                    保留了所有自服务器以来的二进制日志，或则主从服务器都是最近配置的，也可以不进行从服务器的初始化。
                    不过对于已经运行一段时间的数据库来说，这一步(初始化从数据库的数据)是必须的，就算有二进制日志，如果通过二进制日志
                    进行同步也会耗费很多时间，所以不如通过主数据库的备份来完成从数据库的初始化这样更有效率。
                    A.主数据库备份方法:
                        I.进行逻辑备份，使用这个工具对MySQL进行备份时会把数据库中所有的数据库对象找出来存储为一个存储文件，
                          为了保证事务的一致性，要加上-single-transaction参数，使用这个工具要对数据库表进行加锁的，这样会
                          影响数据库的并发性，在一个访问非常频繁的系统中使用这个工具对表进行备份会造成大量阻塞。--master-data参数
                          在备份时记录主库当前的二进制日志的偏移量信息
                          在主数据库服务器上进行备份，并将all.mysql拷贝到 从数据库服务器上
                          > mysqldump --master-data -single-transaction --triggers --routines --all-databases -uroot
                            -p >> all.mysql
                          
                        II. 对于innodb存储引擎，能够做到不阻塞，可以在不影响主库的情况下备份从库
                             但是如果使用了其他的存储引擎(例如MyISAM)，则会造成阻塞情况
                             --slave-info参数在备份时记录主数据库二进制日志信息以及当前的日志偏移量信息
                             在线上环境推荐使用xtrabackup，进行热备份
                          > xtrabackup --slave-info
                          
                    B.从数据库服务器初始化
                        > mysql -uroot -p < all.mysql     (将备份数据库文件进行导入)
                          
            (5) 启动复制连路
                    在从服务器上进行操作，我们可以使用一下SQL语句来告诉备库从主数据库二进制日志的什么位置开始同步数据
                    参数master_log_file和参数master_log_pos在(4)中数据库备份中找到，也就是备库要从主库什么位置开始同步
                    二进制日志的文件名和偏移量
                    在从服务器执行
                    mysql> change master to master_host='主服务器ip',master_user='在主服务器创建用户名',
                          master_password='对应密码'，master_log_file='mysql_log_file_name',master_log_pos=4;
                          
                    例如：
                    mysql> change master to master_host='192.168.1.100',master_user='jame',
                        master_password='123456'，master_log_file='mysql-bin.000003',master_log_pos=1893;
                        
                        其中master_log_file='mysql-bin.000003',master_log_pos=1893;可以查看all.mysql(备份文件)的内容
                    
                          
            (6) 查看复制连路配置
                    mysql> show slave status \G;
            (7) 启动复制连路
                    mysql> start slave;
                    
       2.基于日志点的复制的优缺点:
            优点：
                (1) 是MySQL最早支持的复制技术，Bug相对较少
                (2) 对SQL查询没有任何限制（特别是基于行的复制，对所有SQL语句没有任何要求）
                (3) 故障处理比较容易(网上资料较多)
                
            缺点:
                (1) 故障转移时重新获取新的主数据库的日志点信息比较困难，这在一主多从尤其困难，如果主库发生宕机，我们要从多个从库中
                    找出主库，而其他的从库要对新的主库进行重新同步，由于每一个服务器的二进制日志文件都是独立存在的，所以很难找到
                    其他从库应该和新的主库进行同步的日志点，这一点在后面进行高可用部署时会显得非常重要
                    
                    
  基于GTID复制：
        1.基本原理:
            从库服务器告诉主是服务器以及执行完事务的GTID(全局事务 ID (Global Transaction ID, GTID)）值,然后主库会把所有从库上没有
            执行的事务发送到从库上，使用GTID可以保证同一事务只在指定的从库执行一次
        2.GTID概念:
            GTID即全局事务ID，其保证为每一个在主数据库上提交的事务在复制集群中可以生成一个唯一的ID
            GTID=source_id:transaction_id ,其source_id是server_uuid(确保每一个事务唯一)，
                                           transaction_id是自增序列(在主库上执行的第几个事务)
        3.基于GTID复制的配置步骤:
            (1) 在主DB服务器上建立复制账号(与基于日志点操作一致)
                    需要注意的是一定不能在从服务器建立相同的账号，因为GTID复制会把所有主服务器上的事务都同步到从服务器上去，所以
                    在从服务上手动创建账号，在复制连路是会发生错误
            (2) 配置主数据库服务器(在/etc/my.cnf)修改完后需要重启MySQL服务器
                     I. log-bin=mysql-bin  (用来启动mysql二进制日志，指定mysql二进制日志名字规范 /home/mysql/log/mysql-bin)
                     II. server_id = 100 (在所有数据库中要确保唯一) 
                     III. gtid_mode = on (决定了是否启动GTID模式)
                     IV. enforce-gtid-consiste (强制GTID的一致性,用于启动GTID后事务的安全)
                         副作用：(1) 无法使用create table...select联合语句
                                (2) 无法使用在事务中使用create temporary table 建立临时表
                                (3) 无法使用关联更新事务表和非事务表
                     V. log-slave-updates = on (在从服务器中记录主服务器发送过来的修改日志,mysql5.7版本不需要配置)
                     
            (3) 配置从数据库服务器(修改完后需要重启MySQL服务器)
                     A. server_id = 101
                     B. relay_log = mysql_relay_bin (一定要进行固定，默认是按主机名字进行命名 /home/mysql/log/mysql-relay-bin)
                     C. gtid_mode = on (决定了是否启动GTID模式)
                     D. enforce-gtid-consiste (强制GTID的一致性,用于启动GTID后事务的安全)
                     推荐使用
                     E. log-slave-updates = on
                     F. read_only = on [可选] (安全配置参数)
                     G. master_info_repository = TABLE
                     H. relay_log_info_repository = TABLE 
                     (master_info_repository和relay_log_info_repository这2个参数指定了从服务器连接主服务器的信息以及中继日志信息
                      默认是存储在文件中，设置该参数将信息保存在表中)
                      
            (4) 初始化从数据库的数据(方法和基于日志点操作一致)
                    不同的是记录备份时最后的事务GTID值
                    
            (5) 启动基于GTID的复制
                     参数master_auto_position是告诉MySQL是使用GTID复制
                     > change master to master_host='主服务器ip',master_user='在主服务器创建用户名',
                       master_password='对应密码'，master_auto_position=1;
                       
            (6) 查看复制连路配置
                     mysql> show slave status \G;
                     
            (7) 启动复制连路(只要主库上进行修改，从库对应也会同步)
                     mysql> start slave;
                     
        2.基于GTID的复制的优缺点:
            优点：
                (1) 可以很方便进行故障转移，这是因为GTID的全局唯一的事务标识符，我们根据GTID就会知道哪些事务是没有在从库中执行的，
                    那么在进行故障转移时对多个从服务器也不用通过新的二进制日志偏移量进行同步
                (2) 从库不会丢失主库上的任何修改，因为使用了log-slave-updates(这要保证主库上没有删除二进制日志文件)
                
            缺点:
                (1) 故障处理复杂，比如对于在从库上出现了重复主键的错误，之前我们在保证主从数据没有差异的情况下直接在从库上跳过这个错误
                    就可以了，但是在使用基于GTID复制后无法简单得处理，我们必须要通过在从库上插入空事务的方式才能跳过这种错误
                (2) 对执行的SQL有一定的限制，包括 在事务中使用create temporary table 建立临时表    
                                
                                
  选择复制模式要考虑的问题
        1.使用的MySQL版本，基于GTID复制是在MySQL5.6以后
        2.复制架构及主从切换的方式，基于GTID复制在主从切换更加方便，特别是在一主多从的架构中，不需要担心日志偏移量问题
        3.所使用的高可用管理组件，是否支持主从复制
```

## MySQL复制拓扑

```shell
    1.背景资料
        在MySQL5.7以前，一个从库只能有一个主库，在MySQL5.7以后，支持一从多主架构
        
    2.一主多从的复制拓扑
        I.优缺点
            优点：
                (1) 配置简单，我们可以非常方便得比较不同从库的存放事件主库二进制位置，如果我们对主库进行有计划的停机维护时，
                    就可以利用特性方便进行主从切换，先把主库设置为只读，在所有的从库同步完主库数据后，从多个从库中选出一个新的主库
                    直接进行切换就可以了
    

```