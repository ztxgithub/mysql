# Mysql复制

## Mysql复制概念

```shell
    Mysql 复制功能提供了分担 读负载，通过复制功能对数据库进行水平扩展，为数据库服务器增加一个或多个备库，这些备库可以
          分担读负载。
    Mysql 复制功能为高可用，灾难恢复，备份提供更多的选择。
    Mysql 的复制是基于主库上的二进制日志，Mysql 的复制是异步的，可以存在主从数据库不一致，
    
    Mysql 复制所解决的问题:
        (1) 实现在不同服务器上的数据分布(Mysql 复制是利用二进制日志增量进行，不需要太多的带宽，但是使用基于行的复制在进行
                                    大批量的更改时会对带宽带来一定的压力，应该分批进行)
        (2) 实现数据读取的负载均衡(需要其他组件配合完成，例如利用 DNS 轮询的方式把程序的读 连接到不同的备份数据库中，
                                也可以使用 LVS，haproxy等方式)
        (3) 增加数据的安全性(复制并不能代替备份，复制只是将主库的数据拷贝到从库中，由于主从同步的延时小，
                          如果主库中有大量错误数据, 则从库也很快被同步扩散，不能通过从库恢复到主库，而是得用备份的方式)
        (4) 实现数据库高可用和故障切换。
        (5) 实现数据库的在线升级
        

```

## Mysql二进制日志

```shell
    Mysql日志类型:
        (1) MySQL服务层日志
                例如二进制日志，慢查日志，通用日志，这些日志与存储引擎无关，是由MySQL服务器层来记录的，
        (2) MySQL存储引擎层日志：例如innodb重做日志和innodb回滚日志
        
    二进制日志(binlog)
        记录了所有对MySQL数据库的修改事件，包括增删改查事件和对表结构的修改事件,在binlog日志中记录的事件都是已经成功执行的，对于已经
        回滚的事件不会记录在binlog日志中
        
    二进制日志的格式
        (1) 基于段的格式 
                特点:
                    数据库系统变量binlog_format = STATEMENT,  其记录的是执行的SQL语句,如果数据库采用这种方式，在终端执行
                    mysqlbinlog命令时不需要指定任何参数，就可以清楚得从二进制日志中看出执行了那些二进制语句，
                    不管数据库系统变量binlog_format 是何值，在进行 DDL(表结构操作)时都是用基于段的格式记录在biglog中.
                    
                优点:
                    1.日记记录量相对较小(记录的只是每一个事件的SQL语句)，节约磁盘及网络I/O，只对一条记录修改或则插入，row格式
                      所产生的日志量小于 段产生的日志量
                
                缺点:
                    1.必须记录上下文信息，保证语句在从服务器上执行结果和在主服务器上相同。但是特定函数如UUID(),user(),这样非确定性
                      函数还是无法复制，这可能造成MySQL复制的主备服务器数据不一致。
                        
                        
        (2) 基于行的格式 
                特点:
                    数据库系统变量binlog_format = ROW（MySQL的默认使用格式）,Row可以避免MySQL复制中出现的主从不一致问题，推荐使用
                    这种二进制日志格式，这种日志记录的是增删改查操作所修改数据行的信息，每修改一行就会有一条记录，同一条SQL语句修改了
                    10000条数据的情况下，基于段的二进制日志格式只会记录这个SQL语句，而基于行的二进制日志格式会有10000条记录分别记录
                    每一个行的数据修改
                    
                优点:
                    1.使MySQL主从复制更加安全，由于ROW格式记录每一个记录的修改，所以传到从服务器上只需要应用其更改就行了，而不是按照
                      SQL语句进行应用，在主服务器该了什么，同样的也会在从服务器更改相同的地方，确保主从数据一致。
                    2.ROW格式是记录了每一行的修改，这要比基于段格式的复制要高效，减低主从复制的时间
                    3.误操作而修改了数据库的数据，同时又没有备份可以恢复时，我们就可以通过分析ROW格式二进制日志，
                      对日志中记录的数据修改操作做反向处理的方式来达到恢复数据的目的
                
                缺点:
                    1.记录日志量大，消耗更多的磁盘IO和网络IO
                    
        (3) 混合日志格式
                特定:
                    数据库系统变量binlog_format = MIXED,它是基于段的日志格式和行的日志格式的折衷的选择，
                    1.根据SQL语句由系统决定在基于段的日志格式和基于在行的日志格式中进行选择
                    2.数据量的大小由所执行的SQL语句决定的
    
        
    命令 mysqlbinlog 
       (1) 如果binlog的格式是 段格式(statement)  > mysqlbinlog 二进制日志
       
    如何选择二进制日志格式
        建议： 尽量使用 binlog_format = ROW 或则 binlog_format = MIXED，
              在使用 binlog_format = ROW时，尽量使用 binlog_row_image=MINIMAL
    

```

## MySQL 二进制日志相关的参数

```shell
    1.对于 ROW格式的二进制日志 
            binlog_row_image 值
                (1) FULL(默认的): 一行数据修改时会记录这行所有列的内容，无论这些列是否都被修改过
                (2) MINIMAL: 一行数据修改时只会记录 被修改的列，如果数据库表中有20，SQL操作只update其中这一列，则只会记录这一列的内容
                (3) NOBLOB:跟FULL一样，只不过当text和BLOB没有修改时，是不会记录的
    

```

## 基于二进制日志格式的复制

```shell

    MySQL复制类型
        1.基于SQL语句的复制(SBR)
            主数据库服务器的二进制日志格式使用的是statement格式
        
        2.基于行的复制(RBR)
            主数据库服务器的二进制日志格式使用的是行格式
            
        3.混合格式
            根据实际内容在以上2中模式切换
            
           
    MySQL二进制日志格式对复制的影响
        1.基于SQL语句的复制(SBR)：又称为逻辑复制，在这种模式下，主库的SQL语句对应的在从库上重新执行一次
                优点：
                     (1) 生产日志量少，节约网络传输I/O
                     (2) 并不强制要求主从数据库的表定义完全相同。
                     (3) 相比于基于行的复制方式更加灵活。由于日志记录中就是主库的SQL语句，很容易定位问题的发生
                     
                缺点:
                    (1) 对于非确定性事件，无法保证主从复制数据的一致性。例如特定的函数UUID()在主从执行的结果是不一样的。
                    (2) 对应存储过程，触发器，自定义函数进行修改也可能导致主从数据不一致
                    (3) 相比于行的复制方式，在从数据库上执行时需要更多行锁。 该SQL语句在主库时要锁定多少行数据，同样的对应的从
                        数据库上也要锁定相同的数据。如果使用行复制方式，则只要在从数据库上锁定更新行的数据就行。
                        
        2.基于行的复制(RBR):
                优点：
                    (1) 可以应用于任何SQL语句的复制包括非确定性函数，存储过程等
                    (2) 减少从数据库锁的使用，减少主从复制的时间，增强性能。
                    
                缺点:
                    (1) 要求主从数据库表结构相同，否则可能会中断复制.其主从数据库表列的顺序也要是一样的。
                    (2) 无法在主从上单独执行触发器，基于行的复制是直接在从服务器上 应用主数据库对行的修改，而不是在从服务器上
                        重新执行SQL，所以有时我们只想在从服务器上执行一些触发器以记录数据的变更，比如用于数据抽取，我们就需要
                        在单独从服务器上执行触发器，对某些表的变更进行记录以方便我们做增量抽取，在这种情况下，基于SQL语句的复制
                        是完全可以运行的，因为它只是在从服务器上执行SQL语句，同样会触发我们在从服务器上的触发器。但是基于行的复制
                        是无法工作，在行的复制中并没有执行SQL语句，而是直接应用了对行数据的修改，这样是不会触发在从服务器上的触发器。
                        
        使用建议： 推荐使用基于行的复制，对主从数据的一致性更加有保证
            
```

## MySQL复制的工作方式

```shell

  MySQL复制过程:
    1.主数据库将变更写入二进制日志中(MySQL必须开启记录二进制日志功能)
    2.从数据库读取主数据库的二进制日志的变更信息 写到自身 relay log(中继日志) 中。 要完成这一个过程，需要在从服务器上建立I/O线程，
      这个I/O线程会跟主服务器建立连接，这时在主服务器上建立转储线程(binlog down),从库上的I/O线程通过这个二进制转储线程读取主库上
      的二进制日志的事件，I/O线程不会轮询的读取事件，如果I/O线程已经读完所有变更的事件，就进行sleep等待直到主库发送信号，I/O线程才被唤醒
      继续读主库上的新的二进制日志事件，中继日志的格式和二进制日志格式相同的，我们可以使用mysqlbinlog工具读取中继日志的内容，如何指定从
      什么位置开始读取，复制可以分为 基于日志点的复制 和 基于GTID的复制
      
    3.从服务器重放 relay log中的日志，这个过程由从服务器的SQL线程执行。根据日志格式不同，分为2中执行方式，有
      基于SQL段的日志(从库上重新执行记录的SQL) 和 基于行的日志(从库上直接应用对数据库行的修改)
      
      
  基于日志点的复制：
  
       基本原理:
            在从库服务器中通过读取哪个二进制日志(mysql-binlog.000002)和偏移量进行增量同步，如果指定错误会造成遗漏或则重复，导致
            主从不一致
       1.基于日志点的复制的配置步骤:
            (1) 在主DB服务器上建立复制账号
                    I.创建用户
                        mysql> create user ‘用户名’ @ ‘允许使用的ip网段' identified by '密码'
                        例如
                         mysql> create user ‘jame’ @ ‘192.168.3.%' identified by '123456';
                    II.授权
                        mysql> grant replication slave on *.* to 用户名’ @ ‘允许使用的ip网段'
                        其中 replication slave 是一种权限类型
                        例如
                           mysql> grant replication slave on *.* to 'jame’ @ ‘192.168.3.%';
            (2) 配置主数据库服务器(在/etc/my.cnf)
                    I.  log-bin=mysql-bin  (用来启动mysql二进制日志，指定mysql二进制日志名字规范 /home/mysql/log/mysql-bin)
                    II. server_id = 100 (在所有数据库中要确保唯一)
                    可选：
                        max_binlog_size = 1000M
                        binlog_format = row
                        expire_logs_days = 7
                        sync_binlog = 1
            (3) 配置从数据库服务器
                    I. log-bin = mysql-bin(在从数据库配置binlog方便以后进行主从迁移，故障转移，进行连路复制)
                    II. server_id = 101
                    III. relay_log = mysql_relay_bin (一定要进行固定，默认是按主机名字进行命名 /home/mysql/log/mysql-relay-bin)
                    IV. log_slave_update = on [可选] (如果以后要将该从服务器当做主服务器使用则一定要设置为on)
                    V. read_only = on [可选] (安全配置参数)
                    
            (4) 初始化从数据库的数据
                    在主从服务器配置完成之后，可以准备复制链路，这这之前还要先把主数据库的现有数据拷贝到从服务器中，如果我们的主库中
                    保留了所有自服务器以来的二进制日志，或则主从服务器都是最近配置的，也可以不进行从服务器的初始化。
                    不过对于已经运行一段时间的数据库来说，这一步(初始化从数据库的数据)是必须的，就算有二进制日志，如果通过二进制日志
                    进行同步也会耗费很多时间，所以不如通过主数据库的备份来完成从数据库的初始化这样更有效率。
                    A.主数据库备份方法:
                        I.进行逻辑备份，使用这个工具对MySQL进行备份时会把数据库中所有的数据库对象找出来存储为一个存储文件，
                          为了保证事务的一致性，要加上-single-transaction参数，使用这个工具要对数据库表进行加锁的，这样会
                          影响数据库的并发性，在一个访问非常频繁的系统中使用这个工具对表进行备份会造成大量阻塞。--master-data参数
                          在备份时记录主库当前的二进制日志的偏移量信息
                          在主数据库服务器上进行备份，并将all.mysql拷贝到 从数据库服务器上
                          > mysqldump --master-data=2 -single-transaction --triggers --routines --all-databases -uroot
                            -p >> all.mysql
                          
                        II. 对于innodb存储引擎，能够做到不阻塞，可以在不影响主库的情况下备份从库
                             但是如果使用了其他的存储引擎(例如MyISAM)，则会造成阻塞情况
                             --slave-info参数在备份时记录主数据库二进制日志信息以及当前的日志偏移量信息
                             在线上环境推荐使用xtrabackup，进行热备份
                          > xtrabackup --slave-info
                          
                    B.从数据库服务器初始化
                        > mysql -uroot -p < all.mysql     (将备份数据库文件进行导入)
                          
            (5) 启动复制连路
                    在从服务器上进行操作，我们可以使用一下SQL语句来告诉备库从主数据库二进制日志的什么位置开始同步数据
                    参数master_log_file和参数master_log_pos在(4)中数据库备份中找到，也就是备库要从主库什么位置开始同步
                    二进制日志的文件名和偏移量
                    在从服务器执行
                    mysql> change master to master_host='主服务器ip',master_user='在主服务器创建用户名',
                          master_password='对应密码'，master_log_file='mysql_log_file_name',master_log_pos=4;
                          
                    例如：
                    mysql> change master to master_host='192.168.1.100',master_user='jame',
                        master_password='123456'，master_log_file='mysql-bin.000003',master_log_pos=1893;
                        
                        其中master_log_file='mysql-bin.000003',master_log_pos=1893;可以查看all.mysql(备份文件)的内容
                    
                          
            (6) 查看复制连路配置
                    mysql> show slave status \G;
            (7) 启动复制
                    mysql> start slave;
                    
       2.基于日志点的复制的优缺点:
            优点：
                (1) 是MySQL最早支持的复制技术，Bug相对较少
                (2) 对SQL查询没有任何限制（特别是基于行的复制，对所有SQL语句没有任何要求）
                (3) 故障处理比较容易(网上资料较多)
                
            缺点:
                (1) 故障转移时重新获取新的主数据库的日志点信息比较困难，这在一主多从尤其困难，如果主库发生宕机，我们要从多个从库中
                    找出主库，而其他的从库要对新的主库进行重新同步，由于每一个服务器的二进制日志文件都是独立存在的，所以很难找到
                    其他从库应该和新的主库进行同步的日志点，这一点在后面进行高可用部署时会显得非常重要
                    
                    
  基于GTID复制：
        1.基本原理:
            从库服务器告诉主是服务器以及执行完事务的GTID(全局事务 ID (Global Transaction ID, GTID)）值,然后主库会把所有从库上没有
            执行的事务发送到从库上，使用GTID可以保证同一事务只在指定的从库执行一次
        2.GTID概念:
            GTID即全局事务ID，其保证为每一个在主数据库上提交的事务在复制集群中可以生成一个唯一的ID
            GTID=source_id:transaction_id ,其source_id是server_uuid(确保每一个事务唯一)，
                                           transaction_id是自增序列(在主库上执行的第几个事务)
        3.基于GTID复制的配置步骤:
            (1) 在主DB服务器上建立复制账号(与基于日志点操作一致)
                    需要注意的是一定不能在从服务器建立相同的账号，因为GTID复制会把所有主服务器上的事务都同步到从服务器上去，所以
                    在从服务上手动创建账号，在复制连路是会发生错误
            (2) 配置主数据库服务器(在/etc/my.cnf)修改完后需要重启MySQL服务器
                     I. log-bin=mysql-bin  (用来启动mysql二进制日志，指定mysql二进制日志名字规范 /home/mysql/log/mysql-bin)
                     II. server_id = 100 (在所有数据库中要确保唯一) 
                     III. gtid_mode = on (决定了是否启动GTID模式)
                     IV. enforce-gtid-consiste (强制GTID的一致性,用于启动GTID后事务的安全)
                         副作用：(1) 无法使用create table...select联合语句
                                (2) 无法使用在事务中使用create temporary table 建立临时表
                                (3) 无法使用关联更新事务表和非事务表
                     V. log-slave-updates = on (在从服务器中记录主服务器发送过来的修改日志,mysql5.7版本不需要配置)
                     
            (3) 配置从数据库服务器(修改完后需要重启MySQL服务器)
                     A. server_id = 101
                     B. relay_log = mysql_relay_bin (一定要进行固定，默认是按主机名字进行命名 /home/mysql/log/mysql-relay-bin)
                     C. gtid_mode = on (决定了是否启动GTID模式)
                     D. enforce-gtid-consiste (强制GTID的一致性,用于启动GTID后事务的安全)
                     推荐使用
                     E. log-slave-updates = on
                     F. read_only = on [可选] (安全配置参数)
                     G. master_info_repository = TABLE
                     H. relay_log_info_repository = TABLE 
                     (master_info_repository和relay_log_info_repository这2个参数指定了从服务器连接主服务器的信息以及中继日志信息
                      默认是存储在文件中，设置该参数将信息保存在表中)
                      
            (4) 初始化从数据库的数据(方法和基于日志点操作一致)
                    不同的是记录备份时最后的事务GTID值
                    
            (5) 启动基于GTID的复制
                     参数master_auto_position是告诉MySQL是使用GTID复制
                     > change master to master_host='主服务器ip',master_user='在主服务器创建用户名',
                       master_password='对应密码'，master_auto_position=1;
                       
            (6) 查看复制连路配置
                     mysql> show slave status \G;
                     
            (7) 启动复制连路(只要主库上进行修改，从库对应也会同步)
                     mysql> start slave;
                     
        2.基于GTID的复制的优缺点:
            优点：
                (1) 可以很方便进行故障转移，这是因为GTID的全局唯一的事务标识符，我们根据GTID就会知道哪些事务是没有在从库中执行的，
                    那么在进行故障转移时对多个从服务器也不用通过新的二进制日志偏移量进行同步
                (2) 从库不会丢失主库上的任何修改，因为使用了log-slave-updates(这要保证主库上没有删除二进制日志文件)
                
            缺点:
                (1) 故障处理复杂，比如对于在从库上出现了重复主键的错误，之前我们在保证主从数据没有差异的情况下直接在从库上跳过这个错误
                    就可以了，但是在使用基于GTID复制后无法简单得处理，我们必须要通过在从库上插入空事务的方式才能跳过这种错误
                (2) 对执行的SQL有一定的限制，包括 在事务中使用create temporary table 建立临时表    
                                
                                
  选择复制模式要考虑的问题
        1.使用的MySQL版本，基于GTID复制是在MySQL5.6以后
        2.复制架构及主从切换的方式，基于GTID复制在主从切换更加方便，特别是在一主多从的架构中，不需要担心日志偏移量问题
        3.所使用的高可用管理组件，是否支持主从复制
```

## MySQL复制拓扑

```shell
    1.背景资料
        在MySQL5.7以前，一个从库只能有一个主库，在MySQL5.7以后，支持一从多主架构
        
    2.一主多从的复制拓扑
        I.优缺点
            优点：
                (1) 配置简单，我们可以非常方便得比较不同从库的存放事件主库二进制位置，如果我们对主库进行有计划的停机维护时，
                    就可以利用特性方便进行主从切换，先把主库设置为只读，在所有的从库同步完主库数据后，从多个从库中选出一个新的主库
                    直接进行切换就可以了
                (2) 可以用多个从库分担读负载，由于MySQL的数据同步是异步执行的，所以不能保证所有从库的数据在同一时间都是完全一致的，
                     但是这种拓扑使这种数据差异达到最小化
    
        II.用途
                (1) 为不同业务使用不同的从库，使不同的从库分担不同的业务查询，这样做的好处是我们可以根据不同业务特点使用不同的存储引擎
                    最常见的是分割前后台的查询，因为业务的前台使用的查询和后台使用的查询往往有很大的差距，比如说前台所获取查询数据量
                    比较少，要求查询的速度能够比较快的返回。而后台的同一类查询通常读取的数据量非常的多，同时对于查询的响应时间要求并不像
                    前台那么敏感，所以我们需要对前后台的查询建立不同的索引，把前后台的查询分别指定到不同的从库上，可以方便得进行索引
                    优化，同时也可以使得后台的查询不会影响到前台的业务，所以是一种很好的优化方案。
                    
                (2) 将一台从库放到远程IDC(Internet Data Center 互联网数据中心),用作灾备恢复，一主多从，其从库与一个主库进行连接
                    其同步延时要小。
                (3) 分担主库的读负载
                
    3.主-主复制拓扑(双主复制拓扑)
        I.概要
            组成这种拓扑是由2台主数据库服务器构成，其中每一台和另一台服务器都是互为主从，由于MySQL5.7以前一个从库只能有一个主库，所以
            主从这种架构需要2个MySQL实例，
            
        II. 服务方式
            (1) 主备模式的主主复制 
                    其2个主数据库中，只有一个主数据库对外服务，另外一个是shadow(只读状态并且作为热备使用)，
                    只有当对外服务主数据库发生宕机，才会切换到另外一台，这个模式可以作为高可用
                    
                    主备模式的主主复制配置注意事项
                        (1) 确保两台服务器上的初始数据相同，可以在两台服务器使用备份文件来进行数据恢复方式来完成。更常见的是
                            结合一台已经运行的数据库MySQL来增加另一个的主库，这时我们需要用特殊处理方式，我们可以先在已有数据库上
                            进行备份并且记录下日志点的相关信息，这些信息作为新的主库和老数据库同步时指定偏移量来使用，
                            然后在新的主数据库恢复数据，恢复完成后记下新的主数据库的binlog日志点，这个会在以后将老的主库配置成
                            新的主库使用
                            
                        (2) 确保两台服务器上已经启动binlog并且有不同的server_id
                        (3) 在两台服务器上启动log_slave_updates参数
                        (4) 在初始的备库上启用read_only
                            
                    
            (2) 主主模式的主主复制(不推荐)
                    2个主数据库同时对外提供服务，
                    
                    缺点:
                        (1) 并不是很好的拓扑结构，因为该架构下经常会产生数据冲突而造成复制链路的中断，
                            一旦产生数据冲突，就需要人为的去选择如何解决冲突。
                        (2) 耗费大量的时间
                        (3) 很容易造成数据的丢失
                        
                    主主模式的主主复制配置注意事项
                        (1) 两个主中所操作的表最好能够分开，就是为了能够尽量避免数据冲突，如果我们在不同的主库中只操作不同的表
                            或则数据的话，这样数据就不会产生冲突
                        (2) 使用下面两个参数控制自增ID的生成(避免自增ID的冲突)
                                auto_increment_increment = 2 (增加步长，一次增加多少值，在使用主主复制时，一台按1,3,5.
                                                              另外一台2,4,6， 不会ID冲突)
                                auto_increment_offset = 1|2 (这个决定了自增ID从哪个开始，默认从1开始，在使用主主复制时，需要将
                                                             一台设置为1，另外一台设置为2)
                                
                                
                        
                    适用场景
                        我们要在2个地区部署数据库，并且要保证每一个地区的数据库中都要保存另一个地区数据库的数据，这个时候使用
                        主主模式的主主复制就比较合适。
                        
            (3) 级联复制
                    一个主库对应一个 分发主库 ，一个分发主库对应多个从库，其中分发主库是记录主库传递过来的二进制日志，并把这些日志
                    提供给下面的从库，这样避免的主库由于复制给多个从库产生负载
```

## MySQL复制性能优化

```shell
    影响主从延时的因素
        (1) 主库写入二进制日志的时间以及执行事务的时间。
                对应从库而言也要执行相同的事务的时间(特别是基于段日志格式)，才能与主数据库上的数据保持一致。如果是基于行的日志格式，
                可能在从库上执行的时间要快一点，但是其传入的日志量则要大很多，所以在网络传输上要消耗很多时间。无论是在哪里消耗的时间，
                都会造成主从的延时。
                
                解决方法:
                    控制主库的事务大小，分割大事务为多个小事务。
                        例如我们可以把10万行的变更修改为5000行进行一次提交，原来的10万行需要2分钟，那么5000行只需要6秒钟，
                        这样就大大缩短了可能主从延时的时间
                    
        (2) 二进制日志传输时间(二进制日志量)
                通常我们的主从数据库在同一个IDC内，网络传输速度是足够快，在从服务器中记录中继日志对于数据文件来说也是顺序写，
                所以磁盘IO的性能也不会对写入中继日志造成影响，主要的影响就是二进制日志量
                
                解决方法:
                    (1) 使用MIXED日志格式
                            这样大多数情况下是基于段(SQL)的二进制日志格式，这样可以大大减少二进制日志数据量。
                        另外为了主从数据一致性的考虑,可能要使用行格式(设置 binlog_row_image=MINIMAL)减少二进制日志量的大小
                        
        (3) 通过single-thread 将中继日志写回到从数据库
                默认情况下从数据库只有一个SQL线程，主数据库上并发的修改其在从数据库上变成串行。例如一个大事务导致从数据库同步时
                一直在进行大事务的处理，导致大事务之后的修改迟迟无法更新到从数据库上。我们可以通过将大事务拆分成小事务的方式来缓解
                这个问题，但是如果是修改一个大表的表结构则需要很长的时间，并且无法像大事务那样分割，所以SQL线程同样还是被占用，从而
                造成大量的延时
                
                解决方法:
                    (1) 使用多线程复制(MySQL5.6以后)
                        默认 slave_parallel_type='database'，表明即使分配了多线程复制但一个数据库也最多只能是一个复制线程，
                        可以通过设置为logical_clock
                        在MySQL5.7中可以按照逻辑时钟的方式来分配SQL线程，这样使得多线程复制变得更加实用 
                        
                        多线程复制配置步骤(在从数据库上进行操作)
                            I. mysql> stop slave; (停止复制链路)
                            II. mysql> set global slave_parallel_type='logical_clock';(设置并发类型为逻辑时钟)
                            III. mysql> set global slave_parallel_workers=4; (所需要的复制线程的数量)
                            IV. mysql> start slave;
                      
```

## MySQL复制常见问题处理

```shell
    1.由于数据损坏或则丢失所引起的主从复制错误
         原因：
                (1) 主库或则从库意外宕机引起的错误。
                        当数据库非正常关机，会出现部分二进制日志没有刷新到磁盘的情况，而从库已经有相关事务的记录，当主库重新启动时
                        主从进行同步过程中从库向主库请求对应的某个二进制偏移量时，主库没有保存，这产生主从复制的链路中断错误。
                        
                        解决问题：
                            I. 使用跳过二进制日志事件
                            II. 注入空事务的方式先恢复中断的复制链路，再使用其他方法来对比主从服务器上的数据
                (2) 主库的二进制日志损坏
                        主库每次重启后都会重新生成一个二进制日志文件，而前一个老的二进制日志文件可能会由于意外的关闭被破坏。
                        
                        解决方法：
                          这时我们只能从从数据库中通过change master 命令来重新指定 从库从主库的二进制日志进行同步，这样会丢失
                          主库的更新，使得主从数据库的数据出现差异，因此我们接下来还是要对二进制日志进行修复，以及修复后还要对
                          主从数据库的数据进行检验看是否恢复主从数据的一致性
                        
                (3) 从库的中继日志(relay log)损坏。
                
                       解决方法
                        只要主库的二进制日志没有损坏,我们可以通过 change master 命令来重新指定从库从主库的二进制日志进行同步
                        
    2.在从库进行数据修改造成的主从复制错误
        在进行从服务器配置中，一定要将从库设置为read_only,使从库只读。主从复制非常依赖与主从数据的一致性，如果出现了从库上进行
        修改数据的情况，主从复制的链路可以轻易的中断，如果是业务应用在从服务器进行数据修改很可能出现事务丢失的情况。这样
        只能重新从主库上同步差异的数据，这样从库上修改的数据就会丢失。
        
    3.不唯一的server_id或则server_uuid
        在主从服务器之间如果出现了相同的server_id，在启动主从复制时就会出现错误。如果是从数据库和从数据库之间存在server_uuid，
        则很不容易发现，因为server_uuid是记录在数据目录的auto.conf文件中，而这个文件一旦存在，MySQL在启动时不会重新生成
        server_uuid的，所以我们不注意很容易造成多个从服务器使用同一个server_uuid的问题。具有相同server_uuid的从库可能会丢失
        二进制日志事件，也有可能会重复执行二进制日志事件，也会造成主从切换时由于选中了相同server_id的从库而造成主从同步的主从切换
        失败
        
    4.max_allow_packet设置引起的主从复制错误
        如果从库上设置的最大包参数设置不一致也会造成主从同步的失败，在这种情况下主库可能会记录从库允许最大的包，当从库获得这个
        二进制日志事件时可能会碰到很多问题，如无限得报错或则重试，或则中继日志的损坏。
                    
```

## MySQL复制无法解决的问题

```shell
    1.分担主数据库的写负载
        由于在主从复制中，写入主库上的二进制日志事件最终会在所有的从库进行存放，所以写负载并不会减少
        
        解决方法:
            I. 分库分表
            
    2.单纯主从复制还无法自动进行故障转移及主从切换
    3.主从复制并不能提供读写分离的功能
        为了实现读写分离，我们需要额外的组件
    

```