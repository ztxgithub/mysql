# Mysql复制

## Mysql复制概念

```shell
    Mysql复制功能提供了分担 读负载，通过复制功能对数据库进行水平扩展，为数据库服务器增加一个或多个备库，这些备库可以分担读负载。
    Mysql复制功能为高可用，灾难恢复，备份提供更多的选择。
    Mysql的复制是基于主库上的二进制日志，Mysql的复制是异步的，可以存在主从数据库不一致，
    
    Mysql复制所解决的问题:
        (1) 实现在不同服务器上的数据分布(Mysql复制是利用二进制日志增量进行，不需要太多的带宽，但是使用基于行的复制在进行大批量的
                                     更改时会对带宽带来一定的压力，应该分批进行)
        (2) 实现数据读取的负载均衡(需要其他组件配合完成，例如利用DNS轮询的方式把程序的读 连接到不同的备份数据库中，
                                也可以使用LVS，haproxy等方式)
        (3) 增加数据的安全性(复制并不能代替备份，复制只是将主库的数据拷贝到从库中，由于主从同步的延时小，如果主库中有大量错误数据，
                           则从库也很快被同步扩散，不能通过从库恢复到主库，而是得用备份的方式)
        (4) 实现数据库高可用和故障切换。
        (5) 实现数据库的在线升级
        

```

## Mysql二进制日志

```shell
    Mysql日志类型:
        (1) MySQL服务层日志
                例如二进制日志，慢查日志，通用日志，这些日志与存储引擎无关，是由MySQL服务器层来记录的，
        (2) MySQL存储引擎层日志：例如innodb重做日志和innodb回滚日志
        
    二进制日志(binlog)
        记录了所有对MySQL数据库的修改事件，包括增删改查事件和对表结构的修改事件,在binlog日志中记录的事件都是已经成功执行的，对于已经
        回滚的事件不会记录在binlog日志中
        
    二进制日志的格式
        (1) 基于段的格式 
                特点:
                    数据库系统变量binlog_format = STATEMENT,  其记录的是执行的SQL语句,如果数据库采用这种方式，在终端执行
                    mysqlbinlog命令时不需要指定任何参数，就可以清楚得从二进制日志中看出执行了那些二进制语句，
                    不管数据库系统变量binlog_format 是何值，在进行 DDL(表结构操作)时都是用基于段的格式记录在biglog中.
                    
                优点:
                    1.日记记录量相对较小(记录的只是每一个事件的SQL语句)，节约磁盘及网络I/O，只对一条记录修改或则插入，row格式
                      所产生的日志量小于 段产生的日志量
                
                缺点:
                    1.必须记录上下文信息，保证语句在从服务器上执行结果和在主服务器上相同。但是特定函数如UUID(),user(),这样非确定性
                      函数还是无法复制，这可能造成MySQL复制的主备服务器数据不一致。
                        
                        
        (2) 基于行的格式 
                特点:
                    数据库系统变量binlog_format = ROW（MySQL的默认使用格式）,Row可以避免MySQL复制中出现的主从不一致问题，推荐使用
                    这种二进制日志格式，这种日志记录的是增删改查操作所修改数据行的信息，每修改一行就会有一条记录，同一条SQL语句修改了
                    10000条数据的情况下，基于段的二进制日志格式只会记录这个SQL语句，而基于行的二进制日志格式会有10000条记录分别记录
                    每一个行的数据修改
                    
                优点:
                    1.使MySQL主从复制更加安全，由于ROW格式记录每一个记录的修改，所以传到从服务器上只需要应用其更改就行了，而不是按照
                      SQL语句进行应用，在主服务器该了什么，同样的也会在从服务器更改相同的地方，确保主从数据一致。
                    2.ROW格式是记录了每一行的修改，这要比基于段格式的复制要高效，减低主从复制的时间
                    3.误操作而修改了数据库的数据，同时又没有备份可以恢复时，我们就可以通过分析ROW格式二进制日志，
                      对日志中记录的数据修改操作做反向处理的方式来达到恢复数据的目的
                
                缺点:
                    1.记录日志量大，消耗更多的磁盘IO和网络IO
                    
        (3) 混合日志格式
                特定:
                    数据库系统变量binlog_format = MIXED,它是基于段的日志格式和行的日志格式的折衷的选择，
                    1.根据SQL语句由系统决定在基于段的日志格式和基于在行的日志格式中进行选择
                    2.数据量的大小由所执行的SQL语句决定的
    
        
    命令 mysqlbinlog 
       (1) 如果binlog的格式是 段格式(statement)  > mysqlbinlog 二进制日志
       
    如何选择二进制日志格式
        建议： 尽量使用 binlog_format = ROW 或则 binlog_format = MIXED，
              在使用 binlog_format = ROW时，尽量使用 binlog_row_image=MINIMAL
    

```

## MySQL 二进制日志相关的参数

```shell
    1.对于 ROW格式的二进制日志 
            binlog_row_image 值
                (1) FULL(默认的): 一行数据修改时会记录这行所有列的内容，无论这些列是否都被修改过
                (2) MINIMAL: 一行数据修改时只会记录 被修改的列，如果数据库表中有20，SQL操作只update其中这一列，则只会记录这一列的内容
                (3) NOBLOB:跟FULL一样，只不过当text和BLOB没有修改时，是不会记录的
    

```

## 基于二进制日志格式的复制

```shell

    MySQL复制类型
        1.基于SQL语句的复制(SBR)
            主数据库服务器的二进制日志格式使用的是statement格式
        
        2.基于行的复制(RBR)
            主数据库服务器的二进制日志格式使用的是行格式
            
        3.混合格式
            根据实际内容在以上2中模式切换
            
           
    MySQL二进制日志格式对复制的影响
        1.基于SQL语句的复制(SBR)：又称为逻辑复制，在这种模式下，主库的SQL语句对应的在从库上重新执行一次
                优点：
                     (1) 生产日志量少，节约网络传输I/O
                     (2) 并不强制要求主从数据库的表定义完全相同。
                     (3) 相比于基于行的复制方式更加灵活。由于日志记录中就是主库的SQL语句，很容易定位问题的发生
                     
                缺点:
                    (1) 对于非确定性事件，无法保证主从复制数据的一致性。例如特定的函数UUID()在主从执行的结果是不一样的。
                    (2) 对应存储过程，触发器，自定义函数进行修改也可能导致主从数据不一致
                    (3) 相比于行的复制方式，在从数据库上执行时需要更多行锁。 该SQL语句在主库时要锁定多少行数据，同样的对应的从
                        数据库上也要锁定相同的数据。如果使用行复制方式，则只要在从数据库上锁定更新行的数据就行。
                        
        2.基于行的复制(RBR):
                优点：
                    (1) 可以应用于任何SQL语句的复制包括非确定性函数，存储过程等
                    (2) 减少从数据库锁的使用，减少主从复制的时间，增强性能。
                    
                缺点:
                    (1) 要求主从数据库表结构相同，否则可能会中断复制.其主从数据库表列的顺序也要是一样的。
                    (2) 无法在主从上单独执行触发器，基于行的复制是直接在从服务器上 应用主数据库对行的修改，而不是在从服务器上
                        重新执行SQL，所以有时我们只想在从服务器上执行一些触发器以记录数据的变更，比如用于数据抽取，我们就需要
                        在单独从服务器上执行触发器，对某些表的变更进行记录以方便我们做增量抽取，在这种情况下，基于SQL语句的复制
                        是完全可以运行的，因为它只是在从服务器上执行SQL语句，同样会触发我们在从服务器上的触发器。但是基于行的复制
                        是无法工作，在行的复制中并没有执行SQL语句，而是直接应用了对行数据的修改，这样是不会触发在从服务器上的触发器。
                        
        使用建议： 推荐使用基于行的复制，对主从数据的一致性更加有保证
            
```

## MySQL复制的工作方式

```shell

  MySQL复制过程:
    1.主数据库将变更写入二进制日志中(MySQL必须开启记录二进制日志功能)
    2.从数据库读取主数据库的二进制日志的变更信息 写到自身 relay log(中继日志) 中。 要完成这一个过程，需要在从服务器上建立I/O线程，
      这个I/O线程会跟主服务器建立连接，这时在主服务器上建立转储线程(binlog down),从库上的I/O线程通过这个二进制转储线程读取主库上
      的二进制日志的事件，I/O线程不会轮询的读取事件，如果I/O线程已经读完所有变更的事件，就进行sleep等待直到主库发送信号，I/O线程才被唤醒
      继续读主库上的新的二进制日志事件，中继日志的格式和二进制日志格式相同的，我们可以使用mysqlbinlog工具读取中继日志的内容，如何指定从
      什么位置开始读取，复制可以分为 基于日志点的复制 和 基于GTID的复制
      
    3.从服务器重放 relay log中的日志，这个过程由从服务器的SQL线程执行。根据日志格式不同，分为2中执行方式，有
      基于SQL段的日志(从库上重新执行记录的SQL) 和 基于行的日志(从库上直接应用对数据库行的修改)
      
      
  基于日志点的复制：
       1.基于日志点的复制的配置步骤:
            (1) 在主DB服务器上建立复制账号
                    I.创建用户
                        mysql> create user ‘用户名’ @ ‘允许使用的ip网段' identified by '密码'
                    II.授权
                        mysql> grant replication slave on *.* to 用户名’ @ ‘允许使用的ip网段'
            (2) 配置主数据库服务器
                    I. bin_log=mysql-bin  (用来启动mysql二进制日志，指定mysql二进制日志名字规范)
                    II. server_id = 100 (在所有数据库中要确保唯一)
            (3) 配置从数据库服务器
                    I. bin_log=mysql-bin
                    II. server_id = 101
                    III. relay_log = mysql_relay_bin (一定要进行固定，默认是按主机名字进行命名)
                    IV. log_slave_update = on [可选] (如果以后要将该从服务器当做主服务器使用则一定要设置为on)
    
```